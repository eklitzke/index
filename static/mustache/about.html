<!DOCTYPE html>
<html>
  <head>
    <title>{{title}}</title>
    <link rel="stylesheet" href="{{reset_url}}">
    <link rel="stylesheet" href="{{base_css_url}}" type="text/css">
  </head>
  <body>
    <h1>{{title}}</h1>
    <div class="about">
      This is an implementation of &ldquo;fgrep&rdquo; running on a
      single &ldquo;small&rdquo; EC2 instance. It's indexing the more
      than 600,000 lines of code in the Linux 3.4.4 kernel (including
      all drivers, auxilliary code, headers, tools, etc.).
      <p>
      The basic idea for this implementation is inspired
      by <a href="http://swtch.com/~rsc/regexp/regexp4.html">http://swtch.com/~rsc/regexp/regexp4.html</a>,
      although this implementation is more limited (it does not support
      regexes). Regex support should be coming real soon though.
      <p>
      The implementation uses a custom
      <a href="http://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/">SSTable</a>
      implementation written in C++, using Protocol Buffers. The
      search index is mmap'ed, but not otherwise loaded into memory;
      likewise, there is no caching done on any queries (other than
      the usual page caching that happens on Linux). The search index
      is heavily sharded and multi-threaded, using C++11 threads. The
      sharding logic is mostly what allows the backend to return so
      quickly (i.e. the multi-threading doesn't help on this EC2
      instance, since small instances only have one CPU). The sharding
      level is fairly high (right now, there are about 80 total
      shards), so generally the speedup on a multi-core system would
      be about proportional to the number of cores on that system. On
      my dual-core consumer grade laptop, even pathological queries
      generally return in under 20 milliseconds.
      <p>
      The frontend is written in Python (using tornado), and
      communicates to the backend using a custom asynchronous RPC
      protocol. The protocol is based around Protocol Buffers, and the
      client uses tornado async capabilites and the backend is written
      using boost::asio. Since the entire frontend is fully async, I'm
      using tornado's async decorator and only running a single
      frontend thread/process.
      <p>
      The search index and the RPC protocol both use Google's
      excellent <a href="http://code.google.com/p/snappy/">Snappy</a>
      library for compression.
      <p>
      The Javascript stuff is Zepto + Mustache.js.
    </div>
  </body>
</html>
