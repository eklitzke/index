// Structures stored in the LevelDB database for finding trigrams. The
// way finding a search works is like this.
//
// Suppose you search for the string "index". We generate the following
// trigrams:
//  * ind
//  * nde
//  * dex
//
// For each trigram, we look in the "ngrams" leveldb database keyed by
// values of type NGramKey and holding values of type NGramValue. The
// NGramValue key holds the list of Name ids, in sorted order, usint a
// delta encoding.
//
// We then take the intersection of the position_ids. These are
// candidate matches. We then look up the corresponding rows in the
// "positions" LevelDB database, which is keyed by PositionKey and has
// values of type PositionValue. For each position there may be a
// match on our example query "index". For instance, both of the
// following lines would have matched at this point:
//
//     file_index = 1;       // valid match!
//     indes_codex = "bar";  // invalid match!
//
// To complete the test, we check against the line stored in the
// PositionValue. The PositionValue holds the file_id and the offset
// into that file, which indicates where the line would start.
//
// To get the surrounding file text, information about the language
// that was matched, etc. the file data can be looked up using the
// "files" LevelDB database in the manner that you would expect.

package codesearch;

message IndexConfig {
  required uint64 shard_size = 1;
  required uint64 num_shards = 2;

  enum DatabaseState {
    EMPTY = 0;
    BUILDING = 1;
    COMPLETE = 2;
  }
  optional DatabaseState state = 3 [default = EMPTY];
}

// The format of the SSTable is like this:
//  - 8-bytes, SSTableHeader size (big-endian)
//  - SSTableHeader
//  - padding bytes, to make things word-aligned
//  - index
//  - data
//
// The pad-size is implicit, it's whatever value 8-byte aligns the
// SSTableHeader. To make sure that the SSTable is "valid",
// i.e. completely written, you check that the size of the file is 8 +
// sizeof(SStableHeader) + pad_size + index_size + data_size

message SSTableHeader {
  required uint64 index_size = 1;
  required uint64 data_size = 2;
  required bytes min_value = 3;
  required bytes max_value = 4;
  required uint64 key_size = 5;
  required uint64 num_keys = 6;
}

message FileValue {
  required bytes filename = 1;

  enum Language {
    CLOJURE = 1;
  }
  optional Language lang = 2;

  // The unix timestamp (in seconds) of when we indexed this file.
  optional uint64 time_indexed = 3;

  // The unix timestamp (in seconds) for the file's time in the archive.
  optional uint64 time_archive = 4;
}

message NGramValue {
  repeated uint64 position_ids = 1 [packed=true];
}

message NGramCount {
  required bytes ngram = 1;
  required uint64 count = 2;
}

message NGramCounts {
  repeated NGramCount ngram_counts = 1;
}

message PositionValue {
  required uint64 file_id = 1;
  required uint64 file_offset = 2;
  required uint64 file_line = 3;
  required bytes line = 4;
}

message SearchResult {
  required bytes filename = 1;
  required uint64 line_num = 2;
  required bytes line_text = 3;
}

message SearchQueryRequest {
  required string query = 1;
  optional uint64 limit = 2 [default = 100];
  optional uint64 offset = 3 [default = 0];
}

message SearchQueryResponse {
  repeated SearchResult results = 1;
  optional uint64 time_elapsed = 2;
}

message RPCRequest {
  required uint64 request_num = 1;
  optional string api_key = 2;
  
  // query types go here
  optional SearchQueryRequest search_query = 3;
}

message RPCResponse {
  required uint64 request_num = 1;

  // response types go here
  optional SearchQueryResponse search_response = 2;
}